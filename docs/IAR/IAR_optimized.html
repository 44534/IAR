<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>IAR_optimized</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_IAR_optimized.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">IAR-0.1.0.0: translation of Rabin automata to parity automata using Index Appearance Records</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Clara Waldmann, 2016</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">IAR_optimized</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Helper</a></li><li><a href="#g:2">SCC Decomposition</a></li><li><a href="#g:3">Initial State</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Improvements for IAR procedures: SCC decomposition, finding a good initial state.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:rabin2parity">rabin2parity</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> sigma, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; (<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q sigma l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) sigma <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q sigma l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) sigma <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:applytoboth">applytoboth</a> :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)</li><li class="src short"><a href="#v:fromSubGraph">fromSubGraph</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q s l acc -&gt; <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s -&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.6.2/doc/html/Data-Set.html#t:Set">Set</a> q -&gt; acc -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q s l acc</li><li class="src short"><a href="#v:larWithState">larWithState</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> q, <a href="AR.html#t:AR">AR</a> ar) =&gt; [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s l] -&gt; q -&gt; ar q</li><li class="src short"><a href="#v:sccNodes">sccNodes</a> :: <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s -&gt; ([[<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>]], [[<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>]])</li><li class="src short"><a href="#v:sccs">sccs</a> :: <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s -&gt; ([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s], [<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s])</li><li class="src short"><a href="#v:interestingsccs">interestingsccs</a> :: <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s -&gt; [([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>], [<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>])] -&gt; ([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s], [(<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s, [([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>], [<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>])])])</li><li class="src short"><a href="#v:interestingfs">interestingfs</a> :: [([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>], [<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>])] -&gt; <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s -&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a>]</li><li class="src short"><a href="#v:btwsccs">btwsccs</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l -&gt; (q, q) -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:components">components</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l -&gt; ([<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l], [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l])</li><li class="src short"><a href="#v:connectcomponents">connectcomponents</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s ll -&gt; [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:combineDPAs">combineDPAs</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; q -&gt; [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> q s l] -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> q s l</li><li class="src short"><a href="#v:parsuccs">parsuccs</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> q, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s ll -&gt; [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s l] -&gt; ar q -&gt; [(ar q, s, ar q)]</li><li class="src short"><a href="#v:toDPA">toDPA</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:reduceparitygraph">reduceparitygraph</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s ll -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s l</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:rabin2parity" class="def">rabin2parity</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> sigma, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q sigma l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) sigma <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a>)</td><td class="doc"><p>basic translation of Rabin automata to parity automata (e.g. <code><a href="AR.html#v:rabin2parity">rabin2parity</a></code> from <code><a href="AR.html#t:AR">AR</a></code>)</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q sigma l</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) sigma <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>translate a Rabin automaton into a parity automaton applying the improvements (SCC decomposition, finding a good initial state in each SCC) using the given basic translation</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>IAR_optimized.rabin2parity AR.rabin2parity  exdra :: DPA (IAR Int) Char Int
</code></strong></pre></div></div><h1 id="g:1">Helper</h1><div class="top"><p class="src"><a name="v:applytoboth" class="def">applytoboth</a> :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)</p><div class="doc"><p>apply a function to both components of a pair</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>applytoboth (5+) (1,5)
</code></strong>(6,10)
</pre></div></div><div class="top"><p class="src"><a name="v:fromSubGraph" class="def">fromSubGraph</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q s l acc</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s</td><td class="doc"><p>the graph of the new automaton (subgraph of the old automaton)</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/containers/0.5.6.2/doc/html/Data-Set.html#t:Set">Set</a> q</td><td class="doc"><p>new intial states </p></td></tr><tr><td class="src">-&gt; acc</td><td class="doc"><p>new acceptance condition</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:Automat">Automat</a> q s l acc</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>compute a new automaton from a subgraph of an automaton</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromSubGraph exdra
</code></strong>        (G.mkGraph [(4,()),(5,()),(6,())] [(4,5,'a'),(4,6,'b'),(5,4,'a'),(5,5,'a'),(6,5,'b'),(6,6,'a')]) 
        (S.fromList [4]) 
        [(S.fromList [6], S.fromList [5]),(S.fromList [4,5], S.fromList [6])]
Automat { states = fromList [4,5,6]
        , bimap = fromList [(4,4),(5,5),(6,6)]
        , graph = mkGraph [(4,()),(5,()),(6,())] [(4,5,'a'),(4,6,'b'),(5,4,'a'),(5,5,'a'),(6,5,'b'),(6,6,'a')]
        , start = fromList [4]
        , accept = [(fromList [6],fromList [5]),(fromList [4,5],fromList [6])]
        , aps = Nothing
        }
</pre></div></div><div class="top"><p class="src"><a name="v:larWithState" class="def">larWithState</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> q, <a href="AR.html#t:AR">AR</a> ar) =&gt; [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s l] -&gt; q -&gt; ar q</p><div class="doc"><p>find an Appearance Record in the given automata with a given state component</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>larWithState [IAR_optimized.rabin2parity AR.rabin2parity  exdra :: DPA (IAR Int) Char Int] 4
</code></strong>IAR {state = 4, perm = [1,0]}
</pre></div></div><div class="top"><p class="src"><a name="v:sccNodes" class="def">sccNodes</a> :: <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s -&gt; ([[<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>]], [[<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>]])</p><div class="doc"><p>compute SCCs of a graph (as list of nodes) grouped as (edgeless, cyclic)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sccNodes $ graph exdra
</code></strong>([[1],[2]],[[4,5,6],[7,8],[3]])
</pre></div></div><div class="top"><p class="src"><a name="v:sccs" class="def">sccs</a> :: <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s -&gt; ([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s], [<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s])</p><div class="doc"><p>compute SCCs of a graph (as subgraphs) grouped as (edgeless, cyclic)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sccs $ graph exdra
</code></strong>( [mkGraph [(1,())] [],mkGraph [(2,())] []]
, [ mkGraph [(4,()),(5,()),(6,())] [(4,5,'a'),(4,6,'b'),(5,4,'a'),(5,5,'a'),(6,5,'b'),(6,6,'a')]
  , mkGraph [(7,()),(8,())] [(7,7,'b'),(7,8,'a'),(8,7,'a'),(8,8,'b')]
  , mkGraph [(3,())] [(3,3,'b')]
  ]
)
</pre></div></div><div class="top"><p class="src"><a name="v:interestingsccs" class="def">interestingsccs</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s</td><td class="doc"><p>the graph </p></td></tr><tr><td class="src">-&gt; [([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>], [<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>])]</td><td class="doc"><p>the Rabin pairs translated to nodes in the graph</p></td></tr><tr><td class="src">-&gt; ([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s], [(<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s, [([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>], [<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>])])])</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>compute SCCs of a graph and the pairs that have to be tracked in this SCC
grouped as (SCCs where no pair has to be tracked, SCCs and pairs that have to be tracked)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interestingsccs (graph exdra) [([6],[5]),([4,5],[6]),([1,7],[2,3]),([8],[2])]
</code></strong>([ mkGraph [(1,())] []
 , mkGraph [(2,())] []
 , mkGraph [(7,()),(8,())] [(7,7,'b'),(7,8,'a'),(8,7,'a'),(8,8,'b')]
 ]
,[ (mkGraph [(4,()),(5,()),(6,())] [(4,5,'a'),(4,6,'b'),(5,4,'a'),(5,5,'a'),(6,5,'b'),(6,6,'a')]
   ,[([6],[5]),([4,5],[6])]
   )
 , (mkGraph [(3,())] [(3,3,'b')]
   ,[([1,7],[2,3])]
   )
 ]
)
</pre></div></div><div class="top"><p class="src"><a name="v:interestingfs" class="def">interestingfs</a> :: [([<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>], [<a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Node">Node</a>])] -&gt; <a href="http://hackage.haskell.org/packages/archive/fgl/5.5.2.3/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr">Gr</a> l s -&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a>]</p><div class="doc"><p>compute indices of pairs that have to be tracked in the graph (the final set intersects the graph)</p><p>Example: Let g be the SCC [4,5,6] of the Rabin automaton exdra </p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interestingfs [([6],[5]),([4,5],[6]),([1,7],[2,3]),([8],[2])] g
</code></strong>[0,1]
</pre></div></div><div class="top"><p class="src"><a name="v:btwsccs" class="def">btwsccs</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l -&gt; (q, q) -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>are the two states in different SCCs of the graph of the automaton</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>btwsccs exdra (4,7)
</code></strong>True
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>btwsccs exdra (8,7)
</code></strong>False
</pre></div></div><h1 id="g:2">SCC Decomposition</h1><div class="top"><p class="src"><a name="v:components" class="def">components</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l -&gt; ([<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l], [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l])</p><div class="doc"><p>decompose and restrict a Rabin automaton to its strongly connected components
 they are grouped as (edgeless SCC or SCC where no pair has to be tracked,  restriction of the Rabin automaton to a component)</p></div></div><div class="top"><p class="src"><a name="v:connectcomponents" class="def">connectcomponents</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s ll -&gt; [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a></p><div class="doc"><p>connect the parity automata of the components</p><p>Takes all automata and adds edges between them as in the Rabin automaton.</p></div></div><div class="top"><p class="src"><a name="v:combineDPAs" class="def">combineDPAs</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q =&gt; q -&gt; [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> q s l] -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> q s l</p><div class="doc"><p>combine parity automata to one automaton having the automata as components (no new edges are added) and the union of the acceptance conditions</p></div></div><div class="top"><p class="src"><a name="v:parsuccs" class="def">parsuccs</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Eq.html#t:Eq">Eq</a> q, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s ll -&gt; [<a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s l] -&gt; ar q -&gt; [(ar q, s, ar q)]</p><div class="doc"><p>compute the successors of an Appearance Record in different SCCs</p><p>Example: Let dpas be the parity automata of the SCCs of the Rabin automaton exdra</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parsuccs exdra dpas (IAR 3 [0])
</code></strong>[(IAR {state = 3, perm = [0]},'a',IAR {state = 7, perm = []})]
</pre></div></div><div class="top"><p class="src"><a name="v:toDPA" class="def">toDPA</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Int.html#t:Int">Int</a></p><div class="doc"><p>direct translation of Rabin automata with empty acceptance condition or no edges</p><p>Example: Let tdra be the Rabin automaton exdra restricted to its component [7,8]</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toDPA tdra :: DPA (IAR Int) Char Int
</code></strong>Automat { states = fromList [ IAR {state = 7, perm = []}, IAR {state = 8, perm = []}]
        , bimap = fromList [(IAR {state = 7, perm = []},7),(IAR {state = 8, perm = []},8)]
        , graph = mkGraph [(7,1),(8,1)] [(7,7,'b'),(7,8,'a'),(8,7,'a'),(8,8,'b')]
        , start = fromList [IAR {state = 7, perm = []}]
        , accept = MaxEv {priomap = fromList [(IAR {state = 7, perm = []},1),(IAR {state = 8, perm = []},1)]}
        , aps = Nothing
        }
</pre></div></div><h1 id="g:3">Initial State</h1><div class="top"><p class="src"><a name="v:reduceparitygraph" class="def">reduceparitygraph</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> q, <a href="AR.html#t:AR">AR</a> ar, <a href="http://hackage.haskell.org/packages/archive/base/4.8.2.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (ar q)) =&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DRA">DRA</a> q s ll -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s l -&gt; <a href="http://hackage.haskell.org/packages/archive/omega-automata/0.1.1.0/doc/html/OmegaAutomata-Automata.html#t:DPA">DPA</a> (ar q) s l</p><div class="doc"><p>pick a good initial state by choosing the BSCC of the parity automaton</p><p>Example: let tdra be the Rabin automaton exdra restricted to its SCC [4,5,6]</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>reduceparitygraph tdra $ AR.rabin2parity tdra :: DPA (IAR Int) Char Int
</code></strong>Automat { states = fromList [ IAR {state = 4, perm = [1,0]}
                            , IAR {state = 5, perm = [0,1]}
                            , IAR {state = 5, perm = [1,0]}
                            , IAR {state = 6, perm = [0,1]}
                            , IAR {state = 6, perm = [1,0]}
                            ]
        , bimap = fromList [ (IAR {state = 4, perm = [1,0]},2)
                           , (IAR {state = 5, perm = [0,1]},3)
                           , (IAR {state = 5, perm = [1,0]},4)
                           , (IAR {state = 6, perm = [0,1]},5)
                           , (IAR {state = 6, perm = [1,0]},6)
                           ]
        , graph = mkGraph [(2,1),(3,3),(4,2),(5,2),(6,3)] 
                          [(2,4,'a'),(2,6,'b')
                          ,(3,2,'a'),(3,4,'a')
                          ,(4,2,'a'),(4,4,'a')
                          ,(5,3,'b'),(5,5,'a')
                          ,(6,3,'b'),(6,5,'a')
                          ]
        , start = fromList [IAR {state = 4, perm = [0,1]}]
        , accept = MaxEv {priomap = fromList 
                [ (IAR {state = 4, perm = [0,1]},3)
                , (IAR {state = 4, perm = [1,0]},1)
                , (IAR {state = 5, perm = [0,1]},3)
                , (IAR {state = 5, perm = [1,0]},2)
                , (IAR {state = 6, perm = [0,1]},2)
                , (IAR {state = 6, perm = [1,0]},3)
                ]
                         }
        , aps = Nothing
        }
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>